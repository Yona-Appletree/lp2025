# Cranelift Bug: RV32 generates invalid LD (64-bit load) instruction

## Summary

Cranelift's RISC-V 32-bit backend generates `LD` (64-bit load) instructions, which encode to `funct3=0x3` with opcode `0x03`. However, `funct3=0x3` is **reserved** on RV32 for load instructions. This would cause an illegal instruction exception on real hardware.

## Impact

- **Severity**: High - Code generated by Cranelift would crash on real RV32 hardware
- **Affected**: RV32 code generation when 64-bit loads are attempted
- **Workaround**: Previously worked around in emulator/decoder (now removed)

## Technical Details

### RISC-V Specification

According to the RISC-V ISA specification:
- On RV32, load instructions (opcode `0x03`) support:
  - `funct3=0x0`: LB (load byte)
  - `funct3=0x1`: LH (load halfword)
  - `funct3=0x2`: LW (load word)
  - `funct3=0x3`: **RESERVED**
  - `funct3=0x4`: LBU (load byte unsigned)
  - `funct3=0x5`: LHU (load halfword unsigned)
- `LD` (64-bit load) is only available on RV64, where it uses `funct3=0x3` with opcode `0x03`

### Bug Location

**File**: `cranelift/codegen/src/isa/riscv32/inst/args.rs`

**Function**: `LoadOP::funct3()` (line ~1175)

```rust
pub(crate) fn funct3(self) -> u32 {
    match self {
        Self::Lb => 0b000,
        Self::Lh => 0b001,
        Self::Lw => 0b010,
        Self::Lwu => 0b110,
        Self::Lbu => 0b100,
        Self::Lhu => 0b101,
        Self::Ld => 0b011,  // <-- BUG: LD uses funct3=0x3, which is reserved on RV32
        Self::Flh => 0b001,
        Self::Flw => 0b010,
        Self::Fld => 0b011,
    }
}
```

### Root Cause

Cranelift's RV32 backend includes `LoadOP::Ld` in the `LoadOP` enum and maps it to `funct3=0x3`, but:
1. `LD` is an RV64-only instruction
2. On RV32, `funct3=0x3` for load instructions is reserved
3. The codegen should either:
   - Not generate `LD` instructions on RV32, OR
   - Generate two `LW` instructions to load a 64-bit value on RV32

### Example Failing Instruction

Instruction word: `0x04053503`
- Opcode: `0x03` (load)
- funct3: `0x3` (reserved on RV32)
- RD: `a0` (10)
- RS1: `a0` (10)
- Immediate: `0x40`

This instruction would trigger an illegal instruction exception on real RV32 hardware.

## Fix Required

1. **Prevent generation of `LD` on RV32**: The lowering/legalization passes should ensure `LD` is never generated for RV32 targets
2. **Alternative**: If 64-bit loads are needed, generate two `LW` instructions (load low 32 bits, then high 32 bits)

## Related Files

- `cranelift/codegen/src/isa/riscv32/inst/args.rs` - `LoadOP::funct3()` mapping
- `cranelift/codegen/src/isa/riscv32/lower.isle` - Instruction lowering rules
- `cranelift/codegen/src/isa/riscv32/inst/emit.rs` - Instruction emission

## Test Case

The bug manifests when compiling code that attempts to load 64-bit values on RV32. For example:
- GLSL filetests: `scalar/float/op-subtract.glsl:67` (test_float_subtract_large_numbers)
- Any code path that generates `LD` instructions for RV32

## Status

- **Discovered**: 2026-02-03
- **Workaround removed**: 2026-02-03 (emulator/decoder no longer accept funct3=0x3)
- **Fix implemented**: 2026-02-03

## Fix

### Changes Made

1. **`cranelift/codegen/src/isa/riscv32/lower.isle`** (lines 2742-2755):
   - Modified the general `load` rule to only match types that fit in a single RV32 register (`fits_in_rv32_reg`)
   - This ensures `I64` loads are handled by the register-pair rule (rule 1) which splits them into two `LW` instructions
   - The register-pair rule already existed but wasn't matching because the general rule matched first

2. **`cranelift/codegen/src/isa/riscv32/lower/isle.rs`** (lines 298-311):
   - Fixed `load_ra()` function to use `LoadOP::Lw` instead of `LoadOP::Ld`
   - Changed offset from 8 bytes to 4 bytes (return addresses are 32 bits on RV32)
   - Changed register type from `I64` to `I32`

### Root Cause

The general load rule (`rule (lower (has_type ty (load ...)))`) was matching `I64` types and calling `load_op(I64)` which returns `LoadOP::Ld`. The register-pair rule (`rule 1`) should have matched first (higher priority), but pattern matching in ISLE allowed the general rule to match.

### Solution

By restricting the general rule to only match `fits_in_rv32_reg` types (which excludes `I64`), we ensure that:
- `I64` loads are handled by the register-pair rule (two `LW` instructions)
- Other types (I8, I16, I32) continue to use the appropriate load operations
- No `LD` instructions are generated on RV32

### Testing

After this fix:
- The emulator will correctly reject any `LD` instructions (funct3=0x3) as invalid
- GLSL filetests that previously failed should now pass
- Code generation for RV32 will correctly split 64-bit loads into two 32-bit loads
